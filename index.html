<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Jump</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rubik', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 1000;
        }

        .hidden {
            display: none !important;
        }

        .btn {
            background: linear-gradient(135deg, #4a90e2, #2563eb);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-claim {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .btn-submit {
            background: linear-gradient(135deg, #EAB308, #CA8A04);
            color: black;
        }

        .score-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 30px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            z-index: 100;
        }

        .wallet-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px;
            text-align: center;
            min-width: 300px;
        }

        .wallet-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ef4444;
            display: inline-block;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .wallet-indicator.connected {
            background: #10b981;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(16, 185, 129, 0.95);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: bold;
            z-index: 10000;
            max-width: 90%;
            text-align: center;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 32px;
            margin: 20px 0;
        }

        .game-info {
            font-size: 16px;
            margin: 15px 0;
            line-height: 1.6;
        }

        .reward-box {
            background: rgba(16, 185, 129, 0.2);
            border: 2px solid #10b981;
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
        }

        .reward-box.not-eligible {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
        }

        @media (max-width: 768px) {
            h1 { font-size: 36px; }
            h2 { font-size: 24px; }
            .wallet-info { min-width: auto; width: 90%; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Score Display -->
    <div id="scoreDisplay" class="score-display hidden">Score: 0</div>

    <!-- Main Menu -->
    <div id="mainMenu" class="overlay">
        <h1>üéÆ Super Jump</h1>
        
        <div class="wallet-info">
            <div style="margin-bottom: 10px;">
                <span class="wallet-indicator" id="walletIndicator"></span>
                <span id="walletStatus">Not Connected</span>
            </div>
            <div id="walletAddress" style="font-family: monospace; font-size: 14px; margin: 10px 0;"></div>
            <button class="btn" id="connectBtn" onclick="connectWallet()">Connect Wallet</button>
        </div>

        <div class="game-info">
            üéØ Score 30+ points to earn rewards!<br>
            üí∞ Click left/right to move<br>
            ‚≠ê Land on platforms to jump higher
        </div>

        <div id="prizePoolStatus" style="margin: 10px 0; font-size: 14px; color: rgba(255, 255, 255, 0.8);">
            üí∞ Checking prize pool...
        </div>

        <button class="btn" id="playBtn" onclick="startGame()" disabled>Play Game</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="overlay hidden">
        <h1>Game Over</h1>
        <h2 id="finalScore" style="font-size: 64px; color: #4a90e2;">0</h2>
        
        <div id="rewardEligible" class="reward-box hidden">
            <p style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">üéâ Congratulations!</p>
            <p>You scored 30+ points! Submit to leaderboard and claim your ETH reward!</p>
            <button class="btn btn-submit" onclick="submitScore()" style="margin-top: 10px; width: 100%;">
                üìä Submit to Leaderboard
            </button>
            <button class="btn btn-claim" id="claimBtn" onclick="claimReward()" style="width: 100%;">
                üí∞ Claim ETH Reward
            </button>
        </div>
        
        <div id="rewardNotEligible" class="reward-box not-eligible hidden">
            <p style="font-size: 18px; font-weight: bold; color: #ef4444; margin-bottom: 10px;">üéØ Almost There!</p>
            <p>Score 30+ points to submit to leaderboard and earn ETH!</p>
        </div>
        
        <button class="btn" onclick="restartGame()" style="margin-top: 20px;">üí™ Play Again</button>
    </div>

    <!-- Load Ethers.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.0/dist/ethers.umd.min.js"></script>
    
    <!-- Load AppKit from node_modules via Vite -->
    <script type="module">
        import { createAppKit } from '@reown/appkit';
        import { EthersAdapter } from '@reown/appkit-adapter-ethers';
        import { base } from '@reown/appkit/networks';

        // ============ Configuration ============
        const REOWN_PROJECT_ID = 'e0dd881bad824ac3418617434a79f917';
        const CONTRACT_ADDRESS = "0x603b3b1a946b9ff14280e8581539e07808dc5d0d";
        const ALCHEMY_API_KEY = 'YOUR_ALCHEMY_KEY_HERE'; // Replace with your key
        const BASE_RPC = `https://base-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`;

        const CONTRACT_ABI = [
            "function claimReward(uint256 score, uint256 gameNonce, uint256 timestamp, uint256 farcasterFID, bytes farcasterProof) external",
            "function submitScore(uint256 score, uint256 farcasterFID) external returns (uint256 position)",
            "function getContractBalance() external view returns (uint256)",
            "function getRemainingClaimsForFID(uint256 farcasterFID) external view returns (uint256)",
            "function getPlayerStats(address player) external view returns (uint256 highestScore, uint256 totalGames, uint256 totalRewardsClaimed, uint256 lastPlayTimestamp)"
        ];

        // ============ Global State ============
        let appKitModal = null;
        let provider = null;
        let readProvider = null;
        let connected = false;
        let userAddress = null;
        let gameScore = 0;

        // ============ Initialize Providers ============
        function initReadProvider() {
            readProvider = new ethers.JsonRpcProvider(BASE_RPC, {
                chainId: 8453,
                name: 'base'
            });
        }

        // ============ Initialize Wallet ============
        async function initWallet() {
            try {
                initReadProvider();

                const adapter = new EthersAdapter();
                
                const customBase = {
                    ...base,
                    rpcUrls: {
                        default: { http: [BASE_RPC] },
                        public: { http: ['https://mainnet.base.org'] }
                    }
                };

                appKitModal = createAppKit({
                    adapters: [adapter],
                    projectId: REOWN_PROJECT_ID,
                    networks: [customBase],
                    metadata: {
                        name: 'Super Jump',
                        description: 'Jump game on Base',
                        url: window.location.origin,
                        icons: ['https://super-jump-sand.vercel.app/image.png']
                    },
                    features: { analytics: false }
                });

                appKitModal.subscribeState((state) => {
                    if (state.open === false && !state.loading) {
                        setTimeout(() => checkConnection(), 500);
                    }
                });

                setTimeout(() => checkConnection(), 1000);
                console.log('‚úÖ Wallet initialized');
            } catch (error) {
                console.error('Init error:', error);
            }
        }

        async function checkConnection() {
            try {
                const walletProvider = appKitModal.getWalletProvider();
                if (walletProvider) {
                    provider = new ethers.BrowserProvider(walletProvider);
                    const signer = await provider.getSigner();
                    const address = await signer.getAddress();

                    if (address) {
                        connected = true;
                        userAddress = address;
                        updateUI(true, address);
                        checkPrizePool();
                        return;
                    }
                }
            } catch (error) {
                console.log('Not connected');
            }

            connected = false;
            userAddress = null;
            provider = null;
            updateUI(false);
        }

        function updateUI(isConnected, address = null) {
            const indicator = document.getElementById('walletIndicator');
            const status = document.getElementById('walletStatus');
            const addressEl = document.getElementById('walletAddress');
            const connectBtn = document.getElementById('connectBtn');
            const playBtn = document.getElementById('playBtn');

            if (isConnected && address) {
                indicator.classList.add('connected');
                status.textContent = 'Connected';
                addressEl.textContent = `${address.slice(0, 6)}...${address.slice(-4)}`;
                connectBtn.style.display = 'none';
                playBtn.disabled = false;
            } else {
                indicator.classList.remove('connected');
                status.textContent = 'Not Connected';
                addressEl.textContent = '';
                connectBtn.style.display = 'inline-block';
                playBtn.disabled = true;
            }
        }

        async function checkPrizePool() {
            try {
                if (!readProvider) return;

                const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, readProvider);
                const balance = await contract.getContractBalance();
                const rewardAmount = BigInt(8510638297872);
                const available = balance / rewardAmount;

                const statusDiv = document.getElementById('prizePoolStatus');
                if (balance < rewardAmount) {
                    statusDiv.innerHTML = 'üòî Prize pool empty, play for fun!';
                    statusDiv.style.color = '#ef4444';
                } else if (available < 10n) {
                    statusDiv.innerHTML = `‚ö° Prize pool low - ${available} rewards left!`;
                    statusDiv.style.color = '#EAB308';
                } else {
                    statusDiv.innerHTML = `‚úÖ Prize pool active - ${available}+ rewards available!`;
                    statusDiv.style.color = '#10b981';
                }
            } catch (error) {
                console.error('Prize pool check failed:', error);
            }
        }

        function showMessage(text) {
            const msg = document.createElement('div');
            msg.className = 'message';
            msg.textContent = text;
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 3000);
        }

        // ============ Export to Window ============
        window.connectWallet = async function() {
            if (!appKitModal) {
                showMessage('‚è≥ Initializing...');
                await new Promise(r => setTimeout(r, 1000));
            }
            await appKitModal.open();
        };

        window.startGame = function() {
            if (!connected) {
                showMessage('‚ùå Please connect wallet first!');
                return;
            }

            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('scoreDisplay').classList.remove('hidden');
            
            if (window.game) {
                window.game.start();
            }
        };

        window.restartGame = function() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        };

        window.submitScore = async function() {
            if (!connected) {
                showMessage('‚ùå Connect wallet first!');
                return;
            }

            if (gameScore < 30) {
                showMessage('‚ùå Score must be 30+!');
                return;
            }

            try {
                showMessage('üìù Submitting score...');
                
                const network = await provider.getNetwork();
                if (network.chainId !== 8453n) {
                    showMessage('‚ö†Ô∏è Switch to Base network!');
                    return;
                }

                const signer = await provider.getSigner();
                const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                const tx = await contract.submitScore(gameScore, 0);
                await tx.wait();

                showMessage('üéâ Score submitted!');
            } catch (error) {
                console.error('Submit error:', error);
                showMessage('‚ùå Failed to submit: ' + (error.message || 'Unknown error'));
            }
        };

        window.claimReward = async function() {
            if (!connected) {
                showMessage('‚ùå Connect wallet first!');
                return;
            }

            if (gameScore < 30) {
                showMessage('‚ùå Score must be 30+!');
                return;
            }

            try {
                const btn = document.getElementById('claimBtn');
                btn.disabled = true;
                btn.textContent = '‚è≥ Claiming...';

                showMessage('‚è≥ Checking eligibility...');

                const network = await provider.getNetwork();
                if (network.chainId !== 8453n) {
                    showMessage('‚ö†Ô∏è Switch to Base network!');
                    btn.disabled = false;
                    btn.textContent = 'üí∞ Claim ETH Reward';
                    return;
                }

                const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, readProvider);
                const balance = await contract.getContractBalance();
                const remaining = await contract.getRemainingClaimsForFID(0);

                if (balance < BigInt(8510638297872)) {
                    showMessage('üòî Prize pool empty!');
                    btn.disabled = false;
                    btn.textContent = 'üí∞ Claim ETH Reward';
                    return;
                }

                if (remaining === 0n) {
                    showMessage('‚è∞ Already claimed today!');
                    btn.disabled = false;
                    btn.textContent = 'üí∞ Claim ETH Reward';
                    return;
                }

                const gameNonce = Date.now();
                const timestamp = Math.floor(Date.now() / 1000);
                
                // Create simple proof
                const message = `${userAddress}-0-${Date.now()}`;
                const encoder = new TextEncoder();
                const data = encoder.encode(message);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = new Uint8Array(hashBuffer);
                const proof = '0x' + Array.from(hashArray).map(b => b.toString(16).padStart(2, '0')).join('');

                showMessage('‚è≥ Sending transaction...');

                const signer = await provider.getSigner();
                const contractWithSigner = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                const tx = await contractWithSigner.claimReward(gameScore, gameNonce, timestamp, 0, proof);
                
                showMessage('‚è≥ Waiting for confirmation...');
                await tx.wait();

                showMessage('üéâ Reward claimed! ETH sent to wallet!');
                btn.textContent = '‚úÖ Claimed!';

            } catch (error) {
                console.error('Claim error:', error);
                let msg = '‚ùå Claim failed: ';
                if (error.message.includes('user rejected')) {
                    msg = '‚ö†Ô∏è Transaction cancelled';
                } else if (error.message.includes('FIDAlreadyClaimedToday')) {
                    msg = '‚è∞ Already claimed today!';
                } else if (error.message.includes('ScoreTooLow')) {
                    msg = '‚ùå Score too low!';
                } else {
                    msg += error.message || 'Unknown error';
                }
                showMessage(msg);

                const btn = document.getElementById('claimBtn');
                btn.disabled = false;
                btn.textContent = 'üí∞ Claim ETH Reward';
            }
        };

        // Store score from game
        window.setGameScore = function(score) {
            gameScore = score;
        };

        // Initialize on load
        initWallet();
    </script>

    <!-- Game Logic -->
    <script>
        class SimpleGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                
                this.player = null;
                this.platforms = [];
                this.score = 0;
                this.isPlaying = false;
                this.cameraY = 0;
                
                window.addEventListener('resize', () => this.resize());
                this.setupInput();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupInput() {
                const handleInput = (x) => {
                    if (!this.isPlaying || !this.player) return;
                    if (x < this.canvas.width / 2) {
                        this.player.vx = -300;
                    } else {
                        this.player.vx = 300;
                    }
                };

                this.canvas.addEventListener('click', (e) => handleInput(e.clientX));
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleInput(e.touches[0].clientX);
                });
            }

            start() {
                this.isPlaying = true;
                this.score = 0;
                this.cameraY = 0;
                
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height - 150,
                    vx: 0,
                    vy: 0,
                    size: 40
                };

                this.platforms = [];
                this.createPlatforms();

                document.getElementById('scoreDisplay').classList.remove('hidden');
                this.updateScore();

                this.lastTime = performance.now();
                this.loop();
            }

            createPlatforms() {
                const startY = this.canvas.height - 100;
                for (let i = 0; i < 25; i++) {
                    this.platforms.push({
                        x: Math.random() * (this.canvas.width - 100) + 50,
                        y: startY - (i * 80),
                        width: 90,
                        height: 15,
                        scored: false
                    });
                }
            }

            loop() {
                if (!this.isPlaying) return;

                const now = performance.now();
                const dt = Math.min((now - this.lastTime) / 1000, 0.05);
                this.lastTime = now;

                this.update(dt);
                this.render();

                requestAnimationFrame(() => this.loop());
            }

            update(dt) {
                // Physics
                this.player.vy += 1200 * dt;
                this.player.x += this.player.vx * dt;
                this.player.y += this.player.vy * dt;
                this.player.vx *= 0.95;

                // Wrap screen
                if (this.player.x < 0) this.player.x = this.canvas.width;
                if (this.player.x > this.canvas.width) this.player.x = 0;

                // Platform collision
                if (this.player.vy > 0) {
                    for (const p of this.platforms) {
                        if (this.player.x > p.x - p.width/2 &&
                            this.player.x < p.x + p.width/2 &&
                            this.player.y + this.player.size/2 > p.y &&
                            this.player.y + this.player.size/2 < p.y + p.height) {
                            
                            this.player.vy = -550;
                            this.player.y = p.y - this.player.size/2;
                            
                            if (!p.scored) {
                                p.scored = true;
                                this.score++;
                                this.updateScore();
                            }
                        }
                    }
                }

                // Camera follow
                const targetY = this.player.y - this.canvas.height / 2;
                this.cameraY += (targetY - this.cameraY) * 0.1;

                // Spawn platforms
                while (this.platforms[this.platforms.length - 1].y > this.cameraY - this.canvas.height) {
                    const lastY = this.platforms[this.platforms.length - 1].y;
                    this.platforms.push({
                        x: Math.random() * (this.canvas.width - 100) + 50,
                        y: lastY - 80,
                        width: 90,
                        height: 15,
                        scored: false
                    });
                }

                // Remove old platforms
                this.platforms = this.platforms.filter(p => p.y < this.cameraY + this.canvas.height + 200);

                // Game over
                if (this.player.y > this.cameraY + this.canvas.height + 100) {
                    this.gameOver();
                }
            }

            render() {
                // Clear with gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.save();
                this.ctx.translate(0, -this.cameraY);

                // Draw platforms
                for (const p of this.platforms) {
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(p.x - p.width/2, p.y, p.width, p.height);
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.fillRect(p.x - p.width/2, p.y, p.width, 3);
                }

                // Draw player
                this.ctx.fillStyle = '#10b981';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.size/2, 0, Math.PI * 2);
                this.ctx.fill();

                // Eyes
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x - 8, this.player.y - 5, 5, 0, Math.PI * 2);
                this.ctx.arc(this.player.x + 8, this.player.y - 5, 5, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.fillStyle = 'black';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x - 8, this.player.y - 5, 2, 0, Math.PI * 2);
                this.ctx.arc(this.player.x + 8, this.player.y - 5, 2, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.restore();
            }

            updateScore() {
                document.getElementById('scoreDisplay').textContent = `Score: ${this.score}`;
            }

            gameOver() {
                this.isPlaying = false;
                document.getElementById('scoreDisplay').classList.add('hidden');
                document.getElementById('finalScore').textContent = this.score;
                
                if (this.score >= 30) {
                    document.getElementById('rewardEligible').classList.remove('hidden');
                    document.getElementById('rewardNotEligible').classList.add('hidden');
                } else {
                    document.getElementById('rewardEligible').classList.add('hidden');
                    document.getElementById('rewardNotEligible').classList.remove('hidden');
                }

                window.setGameScore(this.score);
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
        }

        // Initialize game
        window.game = new SimpleGame();
    </script>
</body>
</html>